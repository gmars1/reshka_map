<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Орёл и Решка — Wiki Parser</title>

<style>
body {
    font-family: system-ui, -apple-system, sans-serif;
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
    background: #f0f2f5;
    color: #1c1e21;
}
h1 { text-align: center; color: #1877f2; }

#status {
    padding: 14px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-weight: 600;
    text-align: center;
}
.loading { background: #e7f3ff; color: #1877f2; }
.success { background: #e7f4e8; color: #2b7d32; }
.error   { background: #fbe9e7; color: #d32f2f; }

.season-header {
    margin-top: 30px;
    padding: 12px 20px;
    background: #1c1e21;
    color: white;
    border-radius: 8px 8px 0 0;
    font-size: 1.1em;
}

.episode-row {
    display: flex;
    background: white;
    padding: 12px 20px;
    border-bottom: 1px solid #ebedf0;
}
.episode-row:last-child {
    border-radius: 0 0 8px 8px;
    border-bottom: none;
}

.episode-idx {
    min-width: 110px;
    color: #65676b;
    font-weight: 600;
}
.episode-location {
    flex: 1;
}
</style>
</head>

<body>

<h1>Архив выпусков «Орёл и Решка»</h1>
<div id="status" class="loading">⏳ Загрузка данных…</div>
<div id="output"></div>

<script>
const statusEl = document.getElementById("status");
const outputEl = document.getElementById("output");

const API_URL =
    "https://cyclowiki.org/w/api.php?" +
    new URLSearchParams({
        action: "parse",
        page: "Выпуски_телепередачи_«Орёл_и_решка»",
        section: "2",
        prop: "wikitext",
        format: "json",
        origin: "*"
    });

init();

/* ==================== INIT ==================== */

async function init() {
    try {
        const wikiText = await fetchWikiText();
        const episodes = parseWiki(wikiText);
        renderEpisodes(episodes);
    } catch (e) {
        fail(e.message);
        console.error(e);
    }
}

/* ==================== FETCH ==================== */

async function fetchWikiText() {
    const res = await fetch(API_URL);

    if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
    }

    const data = await res.json();

    if (!data?.parse?.wikitext?.["*"]) {
        throw new Error("Некорректный ответ API");
    }

    return data.parse.wikitext["*"];
}

/* ==================== PARSE ==================== */

function parseWiki(text) {
    const episodes = [];
    const seasonBlocks = text.split(/^===\s*(.+?)\s*===/m);

    for (let i = 1; i < seasonBlocks.length; i += 2) {
        const season = seasonBlocks[i].trim();
        const content = seasonBlocks[i + 1];
        if (!content) continue;

        const tables = content.match(/\{\|[\s\S]*?\|\}/g) || [];
        tables.forEach(table => parseTable(table, season, episodes));
    }

    return episodes;
}

function parseTable(table, season, episodes) {
    table.split(/\n\|-/).forEach(row => {
        const clean = row.trim();
        if (!clean || clean.startsWith("!") || clean.includes("|}")) return;

        const cells = clean
            .split(/\|\||(?<=\n)\|/)
            .map(c => c.trim())
            .filter(Boolean);

        const idx = extractIndex(cells);
        if (!idx) return;

        const locations = extractLocations(cells);
        if (locations.length === 0) return;

        episodes.push({
            season,
            idx,
            location: locations.join("; ")
        });
    });
}

/* ==================== EXTRACTORS ==================== */

function extractIndex(cells) {
    const bold = cells.join(" ").match(/'''([^']+)'''/);
    if (bold) return bold[1].trim();

    const fallback = cells[0].match(/\d+[\d\s()]+/);
    return fallback ? fallback[0].trim() : null;
}

function extractLocations(cells) {
    const locations = [];

    cells.forEach(cell => {
        const flags = [...cell.matchAll(/\{\{[Фф]лаг\|([^}|]+)/g)]
            .map(m => m[1].trim());

        const links = cell.match(/\[\[([^|\]]+)(?:\|[^\]]+)?\]\]/g) || [];
        const names = links
            .map(l => l.replace(/[\[\]]/g, "").split("|").pop().trim())
            .filter(name =>
                name.length > 1 &&
                !/^(Файл|File|Image|Категория):/i.test(name) &&
                !/^\d+\s*px$/i.test(name) &&
                !name.toLowerCase().includes("px")
            );

        if (names.length === 0) return;

        const city = names[0];
        const countries = flags.filter(f => f.toLowerCase() !== city.toLowerCase());
        const prefix = [...new Set(countries)].join("/");

        const label = prefix ? `${prefix}: ${city}` : city;
        if (!locations.includes(label)) locations.push(label);
    });

    return locations;
}

/* ==================== RENDER ==================== */

function renderEpisodes(episodes) {
    if (episodes.length === 0) {
        fail("Ничего не найдено");
        return;
    }

    let html = "";
    let currentSeason = "";

    episodes.forEach(ep => {
        if (ep.season !== currentSeason) {
            currentSeason = ep.season;
            html += `<div class="season-header">${escapeHtml(currentSeason)}</div>`;
        }

        html += `
        <div class="episode-row">
            <span class="episode-idx">${escapeHtml(ep.idx)}</span>
            <span class="episode-location">${escapeHtml(ep.location)}</span>
        </div>`;
    });

    outputEl.innerHTML = html;
    statusEl.textContent = `✅ Загружено выпусков: ${episodes.length}`;
    statusEl.className = "success";
}

/* ==================== UTILS ==================== */

function escapeHtml(str = "") {
    return str.replace(/[&<>"']/g, m =>
        ({ "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;" }[m])
    );
}

function fail(msg) {
    statusEl.textContent = "❌ " + msg;
    statusEl.className = "error";
}
</script>

</body>
</html>
