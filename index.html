<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Орёл и Решка — Интерактивная карта</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
html, body {
    margin: 0;
    height: 100%;
    font-family: system-ui, -apple-system, sans-serif;
    background: #f0f2f5;
}

#map {
    height: 100%;
    width: 100%;
}

.panel {
    position: absolute;
    top: 16px;
    right: 16px;
    width: 300px;
    max-height: 85vh;
    background: white;
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 10px 25px rgba(0,0,0,.15);
    overflow: auto;
    z-index: 1000;
}

.panel h2 {
    margin: 0 0 10px;
    font-size: 18px;
    color: #1877f2;
}

#status {
    font-size: 13px;
    margin-bottom: 10px;
}

.log {
    font-size: 11px;
    color: #555;
    max-height: 200px;
    overflow: auto;
}
.ok { color: #2e7d32; }
.err { color: #d32f2f; }
</style>
</head>

<body>

<div id="map"></div>

<div class="panel">
    <h2>Орёл и Решка</h2>
    <div id="status">⏳ Загрузка данных…</div>
    <div id="log" class="log"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ==================== MAP ==================== */

const map = L.map("map").setView([20, 0], 2);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "© OpenStreetMap contributors"
}).addTo(map);

const markers = L.featureGroup().addTo(map);

const statusEl = document.getElementById("status");
const logEl = document.getElementById("log");

/* ==================== API ==================== */

const API_URL =
    "https://cyclowiki.org/w/api.php?" +
    new URLSearchParams({
        action: "parse",
        page: "Выпуски_телепередачи_«Орёл_и_решка»",
        section: "2",
        prop: "wikitext",
        format: "json",
        origin: "*"
    });

init();

/* ==================== INIT ==================== */

async function init() {
    try {
        const wikiText = await fetchWiki();
        const episodes = parseWiki(wikiText);
        await plotEpisodes(episodes);
        statusEl.textContent = `✅ Точек на карте: ${markers.getLayers().length}`;
        if (markers.getLayers().length) {
            map.fitBounds(markers.getBounds().pad(0.15));
        }
    } catch (e) {
        statusEl.textContent = "❌ " + e.message;
        console.error(e);
    }
}

/* ==================== FETCH ==================== */

async function fetchWiki() {
    const res = await fetch(API_URL);
    if (!res.ok) throw new Error("Ошибка API");

    const data = await res.json();
    if (!data?.parse?.wikitext?.["*"]) {
        throw new Error("Некорректный ответ API");
    }
    return data.parse.wikitext["*"];
}

/* ==================== PARSER ==================== */

function parseWiki(text) {
    const episodes = [];
    const blocks = text.split(/^===\s*(.+?)\s*===/m);

    for (let i = 1; i < blocks.length; i += 2) {
        const season = blocks[i].trim();
        const content = blocks[i + 1];
        if (!content) continue;

        const tables = content.match(/\{\|[\s\S]*?\|\}/g) || [];
        tables.forEach(table => {
            table.split(/\n\|-/).forEach(row => {
                const clean = row.trim();
                if (!clean || clean.startsWith("!") || clean.includes("|}")) return;

                const cells = clean
                    .split(/\|\||(?<=\n)\|/)
                    .map(c => c.trim())
                    .filter(Boolean);

                const idx = extractIndex(cells);
                if (!idx) return;

                const locations = extractLocations(cells);
                if (!locations.length) return;

                episodes.push({
                    season,
                    idx,
                    location: locations.join("; ")
                });
            });
        });
    }
    return episodes;
}

function extractIndex(cells) {
    const bold = cells.join(" ").match(/'''([^']+)'''/);
    if (bold) return bold[1].trim();
    const fallback = cells[0].match(/\d+[\d\s()]+/);
    return fallback ? fallback[0].trim() : null;
}

function extractLocations(cells) {
    const out = [];

    cells.forEach(cell => {
        const flags = [...cell.matchAll(/\{\{[Фф]лаг\|([^}|]+)/g)]
            .map(m => m[1].trim());

        const links = cell.match(/\[\[([^|\]]+)(?:\|[^\]]+)?\]\]/g) || [];
        const names = links
            .map(l => l.replace(/[\[\]]/g, "").split("|").pop().trim())
            .filter(n =>
                n.length > 1 &&
                !/^(Файл|File|Image|Категория):/i.test(n) &&
                !/px/i.test(n)
            );

        if (!names.length) return;

        const city = names[0];
        const countries = flags.filter(f => f.toLowerCase() !== city.toLowerCase());
        const prefix = [...new Set(countries)].join("/");

        const label = prefix ? `${prefix}: ${city}` : city;
        if (!out.includes(label)) out.push(label);
    });

    return out;
}

/* ==================== MAP PLOT ==================== */

async function plotEpisodes(episodes) {
    statusEl.textContent = `Найдено выпусков: ${episodes.length}`;

    for (let i = 0; i < episodes.length; i++) {
        const ep = episodes[i];
        const en = translateLocation(ep.location);
        const coords = await geocode(en);

        if (coords) {
            L.marker(coords)
                .bindPopup(`<b>${ep.idx}</b><br>${ep.location}<br><i>${en}</i>`)
                .addTo(markers);

            log(`✔ ${en}`, "ok");
        } else {
            log(`✖ ${en}`, "err");
        }

        statusEl.textContent = `Обработано ${i + 1} / ${episodes.length}`;
        if (!localStorage.getItem("geo_" + en)) {
            await sleep(1000);
        }
    }
}

/* ==================== GEOCODE ==================== */

async function geocode(name) {
    const key = "geo_" + name;
    const cached = localStorage.getItem(key);
    if (cached) return JSON.parse(cached);

    try {
        const res = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(name)}&limit=1`,
            { headers: { "User-Agent": "orel-reshka-map" } }
        );
        const data = await res.json();
        if (data[0]) {
            const coords = [+data[0].lat, +data[0].lon];
            localStorage.setItem(key, JSON.stringify(coords));
            return coords;
        }
    } catch {}
    return null;
}

/* ==================== TRANSLATE ==================== */

function translateLocation(ru) {
    return ru.split(";").map(part =>
        part.split(/[:\/]/).map(p =>
            geoDict.countries[p.trim()] ||
            geoDict.cities[p.trim()] ||
            p.trim()
        ).join(", ")
    ).join(" | ");
}

/* ==================== UTILS ==================== */

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function log(msg, cls) {
    logEl.innerHTML = `<div class="${cls}">${msg}</div>` + logEl.innerHTML;
}

/* ==================== DICT ==================== */
// (твой geoDict — без изменений)
</script>

</body>
</html>
